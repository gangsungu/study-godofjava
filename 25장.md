## 25장. 쓰레드는 개발자라면 알아두는 것이 좋아요

* 쓰레드(Thread)
    - 프로세스 내에서 실제로 작업을 수행하는 단위
    - 하나의 프로세스는 여러개의 쓰레드를 가질 수 있다
    - 메모리(힙, 메소드 영역)을 다른 쓰레드와 공유
    - 각각의 쓰레드는 자신만의 스택 메모리(JVM 관리영역)를 가짐
    -  특징
        + main() 함수가 시작되면서 하나의 메인 쓰레드가 시작
        + 쓰레드를 추가로 생성하여 병렬 처리 가능
            + 동기화 문제를 유의해야 한다

* Thread와 Runnable의 차이
    ```java
    class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Thread 실행 중...");
        }

        public static void main(String[] args) {
            MyThread t = new MyThread(); // 쓰레드 객체 생성
            t.start();                   // run()이 새로운 쓰레드에서 실행됨
        }
    }
    ```
    - Thread 자체가 run 메소드를 가지고 있음
    - Thread 클래스를 상속 중이므로 다른 클래스를 상속할 수 없음
    - Thread 객체가 작업 단위이며 실행 주체가 책임이 겹친다
        + 로직과 실행이 결합되어 있어 재사용성이 낮다
        + 테스트와 유지보수가 어려움

    ```java
    class MyRunnable implements Runnable {
        @Override
        public void run() {
            System.out.println("Runnable 실행 중...");
        }

        public static void main(String[] args) {
            Runnable r = new MyRunnable();     // 작업 단위
            Thread t = new Thread(r);          // 실행 담당
            t.start();
        }
    }
    ```
    - Runnable은 작업 로직만 정의하고 Thread가 실행을 담당
        + 역할 분리 원칙이 적용되어 유지보수와 확장에 유리하다

* Synchronized
    - 여러 쓰레드가 공유자원(변수, 메소드)에 접근할 때, 한 쓰레드가 접속한 동안 다른 쓰레드의 접근을 막는 역할
        + 메소드나 블록에 붙여서 사용한다
    ```java
    class Counter {
        private int count = 0;

        public void increment() {
            count++;
        }

        public int getCount() {
            return count;
        }
    }
    ```
    > 멀티 쓰레드 환경에서는 여러 쓰레드가 동시에 increment()를 호출하면 정상적으로 값이 반영되지 않는 경우가 발생할 수도 있다
    ```java
    public synchronized void increment() {
        count++;
    }
    // 메소드 동기화

    public void increment() {
        synchronized (this) {
            count++;
        }
    }
    // 블록 동기화
    ```
    - 모든 접근에 락을 걸면 병렬 처리가 제한되어 느려질 수 있다
    - 데드락(Deadlock) 발생 위험이 있다

* volatile
    - 멀티쓰레딩 환경에서 가시성 문제를 해결하기 위한 키워드
        + 멀티쓰레드 환경에서는 각 쓰레드가 자신만의 캐시 메모리를 사용하므로 문제 요지 발생
    ```java
    class MyTask {
        // private boolean running = true;

        // volatile을 사용하면 running 값의 변경이 모든 쓰레드에 즉시 반영
        private volatile boolean running = true;    

        public void stop() {
            running = false;
        }

        public void run() {
            while (running) {
                // 작업 수행
            }
        }
    }
    ```
    > main() 메소드가 stop()을 호출해서 running을 false로 설정해도 run()을 실행 중인 쓰레드는 자기 캐시에 저장된 running == true를 계속 보고 있을 수 있다

    |항목|설명|
    |---|---|
    |목적| **가시성 보장** (값 변경을 모든 쓰레드가 즉시 알도록)|
    |원자성 보장| ❌ 보장하지 않음 (복합 연산에는 적합하지 않음)|
    |사용 예|상태 플래그, stop 신호, 단일 읽기/쓰기 변수 등|
    |사용 예제|`private volatile boolean running = true;`|
    |대체 수단|`AtomicInteger`, `synchronized` (원자성도 필요할 때)|

* volatile의 한계
    - volatile은 가시성은 보장하지만 원자성은 보장하지 않는다
    |용어|설명|
    |---|---|
    |**가시성** (Visibility)|한 쓰레드의 변경 내용이 **다른 쓰레드에 즉시 보이는가?**<br>👉 `volatile`이 이걸 보장함|
    |**원자성** (Atomicity)|어떤 연산이 **쪼개지지 않고 단일 단위로 수행**되는가? <br>👉 `volatile`은 이걸 **보장하지 못함**|
    ```java
    class Counter {
        private volatile int count = 0;

        public void increment() {
            count++;
        }

        public int getCount() {
            return count;
        }
    }
    ```
    > volatile 키워드덕분에 가시성은 보장되어 모든 쓰레드는 항상 최신 값을 본다 하지만 중간에 다른 쓰레드가 끼어들면 원자적이지 않아 경쟁조건이 발생한다
    - 쓰레드 A와 B가 count를 읽어 +1 연산을 했지만 실제값은 하나만 반영

* 프로세스(Process)
    - 운영체제에서 실행 중인 하나의 프로그램
    - 다른 프로세스와 메모리를 공유하지 않는다
    - 자바 프로그램을 실행하면 JVM이 하나의 프로세스로 생성됨
        + 각 자바 프로그램은 별도의 프로세스로 실행되며 서로의 자원에 직접 접근이 불가하다