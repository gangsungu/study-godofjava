## 22장. 자바랭 다음으로 많이 쓰는 애들은 컬렉션 - List

* List
    - 자바 컬렉션 프레임워크에서 제공하는 인터페이스
    - 순서가 유지되고 중복 요소를 허용하는 자료구조
    - 배열과 유사하지만 크기가 동적으로 변할 수 있다

    |구현체|특징|사용 예|
    |---|---|---|
    |ArrayList|배열 기반, 빠른 검색, 삽입/삭제 느림|일반적인 리스트 활용|
    |LinkedList|연결 리스트 기반, 삽입/삭제 빠름, 검색 느림|빈번한 삽입/삭제가 필요한 경우|
    |Vector|ArrayList와 유사하지만 동기화 지원|멀티스레드 환경에서 사용|
    |Stack|후입선출(LIFO) 구조로 동작|스택 자료구조 구현|
    
* Big-O
    |연산|ArrayList|LinkedList|
    |---|---|---|
    |검색(get, index 접근)|O(1) (빠름)|O(n) (느림)|
    |중간 삽입/삭제|O(n) (배열 이동 필요)|O(1) (참조 변경)|
    |앞/뒤 삽입/삭제|O(n) (앞에서 이동 필요)|O(1) (첫/끝 노드만 변경)|
    > 데이터를 자주 검색하는 경우 : ArrayList<br/>
    > 중간에서 요소 삽입/삭제가 많은 경우 : LinkedList

* ArrayList와 LinkedList의 차이
    - 리스트 자료구조를 제공하지만 내부 동작 방식이 다름

    |리스트|내부 구조|
    |---|---|
    |ArrayList|배열 기반 > 연속된 메모리에 요소 저장|
    |LinkedList|이중 연결 리스트 기반 > 각 요소가 이전/다음 요소를 참조|
    > ArrayList는 배열처럼 인덱스를 통해 요소에 빠르게 접근 가능하지만 요소를 추가/삭제할 때는 배열을 이동하므로 속도가 느림<br/>
    > LinkedList는 요소 추가/삭제가 빠르지만 순차 검색이 필요하므로 접근 속도가 느림
    ```java
    import java.util.ArrayList;
    import java.util.List;

    public class Main {
        public static void main(String[] args) {
            List<String> arrayList = new ArrayList<>();

            arrayList.add("Java");
            arrayList.add("Python");
            arrayList.add("C++");

            System.out.println(arrayList.get(1));  // 빠른 접근 (O(1))
        }
    }

    import java.util.LinkedList;
    import java.util.List;

    public class Main {
        public static void main(String[] args) {
            List<String> linkedList = new LinkedList<>();

            linkedList.add("Java");
            linkedList.add("Python");
            linkedList.add("C++");

            linkedList.add(1, "JavaScript");  // 중간 삽입 (O(1))
            System.out.println(linkedList);
        }
    }
    ```

* Stack
    - Last In First Out : 가장 나중에 입력된 자료를 가장 먼저 꺼낼 수 있음
    - 맨 마지막 위치(top)에서만 자료를 추가, 삭제, 꺼내올 수 있음
    ```java
    import java.util.Stack;

    public class Main {
        public static void main(String[] args) {
            Stack<Integer> stack = new Stack<>();

            stack.push(10);  // 요소 추가
            stack.push(20);
            stack.push(30);

            System.out.println("스택: " + stack);  // 출력: [10, 20, 30]

            System.out.println("맨 위 요소: " + stack.peek());  // 출력: 30
            System.out.println("요소 제거: " + stack.pop());  // 출력: 30 제거됨
            System.out.println("변경된 스택: " + stack);  // 출력: [10, 20]
        }
    }
    ```

* Deque
    - 자바 1.6부터 지원하는 인터페이스로 양쪽 끝에서 추가, 삭제가 가능한 양방향 대기열을 지원함으로서 스택, 큐를 사용할 수 있다
    - 인덱스를 통해 검색, 추가 삭제가 불가능하다

* Stack보다 Deque의 사용을 권장하는 이유
    - Stack은 Vector를 상속하여 사용하는데, Vector는 Thread Safe를 위한 전통적인 방법이다 여기서 문제점이 발생한다
        + 모든 작업에서 Lock이 걸려 성능저하를 발생시킬 수 있다
        + 단일 스레드 작업시 성능저하가 발생할 수 있다
    - Deque는 Thread Safe를 지원하지 않기 때문에 Stack보다 더 나은 성능을 보여줄 수 있다